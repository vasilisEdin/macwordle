{"ast":null,"code":"import { solution } from './words';\nimport { ORTHOGRAPHY_PATTERN } from './tokenizer';\nexport const getStatuses = guesses => {\n  const charObj = {};\n  const solutionChars = solution.split(ORTHOGRAPHY_PATTERN).filter(i => i);\n  guesses.forEach(word => {\n    word.forEach((letter, i) => {\n      if (!solutionChars.includes(letter)) {\n        // make status absent\n        return charObj[letter] = 'absent';\n      }\n\n      if (letter === solutionChars[i]) {\n        //make status correct\n        return charObj[letter] = 'correct';\n      }\n\n      if (charObj[letter] !== 'correct') {\n        //make status present\n        return charObj[letter] = 'present';\n      }\n    });\n  });\n  return charObj;\n};\nexport const getGuessStatuses = guess => {\n  const splitSolution = solution.split(ORTHOGRAPHY_PATTERN).filter(i => i);\n  const splitGuess = guess;\n  const solutionCharsTaken = splitSolution.map(_ => false);\n  const statuses = Array.from(Array(guess.length)); // handle all correct cases first\n\n  splitGuess.forEach((letter, i) => {\n    if (letter === splitSolution[i]) {\n      statuses[i] = 'correct';\n      solutionCharsTaken[i] = true;\n      return;\n    }\n  });\n  splitGuess.forEach((letter, i) => {\n    if (statuses[i]) return;\n\n    if (!splitSolution.includes(letter)) {\n      // handles the absent case\n      statuses[i] = 'absent';\n      return;\n    } // now we are left with \"present\"s\n\n\n    const indexOfPresentChar = splitSolution.findIndex((x, index) => x === letter && !solutionCharsTaken[index]);\n\n    if (indexOfPresentChar > -1) {\n      statuses[i] = 'present';\n      solutionCharsTaken[indexOfPresentChar] = true;\n      return;\n    } else {\n      statuses[i] = 'absent';\n      return;\n    }\n  });\n  return statuses;\n};","map":{"version":3,"sources":["C:/Users/Vasilis/Documents/nodetest/wordle/macwordle/src/lib/statuses.ts"],"names":["solution","ORTHOGRAPHY_PATTERN","getStatuses","guesses","charObj","solutionChars","split","filter","i","forEach","word","letter","includes","getGuessStatuses","guess","splitSolution","splitGuess","solutionCharsTaken","map","_","statuses","Array","from","length","indexOfPresentChar","findIndex","x","index"],"mappings":"AAAA,SAASA,QAAT,QAAyB,SAAzB;AAEA,SAASC,mBAAT,QAAoC,aAApC;AAMA,OAAO,MAAMC,WAAW,GACtBC,OADyB,IAES;AAClC,QAAMC,OAAsC,GAAG,EAA/C;AACA,QAAMC,aAAa,GAAGL,QAAQ,CAACM,KAAT,CAAeL,mBAAf,EAAoCM,MAApC,CAA4CC,CAAD,IAAOA,CAAlD,CAAtB;AACAL,EAAAA,OAAO,CAACM,OAAR,CAAiBC,IAAD,IAAU;AACxBA,IAAAA,IAAI,CAACD,OAAL,CAAa,CAACE,MAAD,EAASH,CAAT,KAAe;AAC1B,UAAI,CAACH,aAAa,CAACO,QAAd,CAAuBD,MAAvB,CAAL,EAAqC;AACnC;AACA,eAAQP,OAAO,CAACO,MAAD,CAAP,GAAkB,QAA1B;AACD;;AAED,UAAIA,MAAM,KAAKN,aAAa,CAACG,CAAD,CAA5B,EAAiC;AAC/B;AACA,eAAQJ,OAAO,CAACO,MAAD,CAAP,GAAkB,SAA1B;AACD;;AAED,UAAIP,OAAO,CAACO,MAAD,CAAP,KAAoB,SAAxB,EAAmC;AACjC;AACA,eAAQP,OAAO,CAACO,MAAD,CAAP,GAAkB,SAA1B;AACD;AACF,KAfD;AAgBD,GAjBD;AAmBA,SAAOP,OAAP;AACD,CAzBM;AA2BP,OAAO,MAAMS,gBAAgB,GAAIC,KAAD,IAAmC;AACjE,QAAMC,aAAa,GAAGf,QAAQ,CAACM,KAAT,CAAeL,mBAAf,EAAoCM,MAApC,CAA4CC,CAAD,IAAOA,CAAlD,CAAtB;AACA,QAAMQ,UAAU,GAAGF,KAAnB;AAEA,QAAMG,kBAAkB,GAAGF,aAAa,CAACG,GAAd,CAAmBC,CAAD,IAAO,KAAzB,CAA3B;AAEA,QAAMC,QAAsB,GAAGC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACP,KAAK,CAACS,MAAP,CAAhB,CAA/B,CANiE,CAQjE;;AACAP,EAAAA,UAAU,CAACP,OAAX,CAAmB,CAACE,MAAD,EAASH,CAAT,KAAe;AAChC,QAAIG,MAAM,KAAKI,aAAa,CAACP,CAAD,CAA5B,EAAiC;AAC/BY,MAAAA,QAAQ,CAACZ,CAAD,CAAR,GAAc,SAAd;AACAS,MAAAA,kBAAkB,CAACT,CAAD,CAAlB,GAAwB,IAAxB;AACA;AACD;AACF,GAND;AAQAQ,EAAAA,UAAU,CAACP,OAAX,CAAmB,CAACE,MAAD,EAASH,CAAT,KAAe;AAChC,QAAIY,QAAQ,CAACZ,CAAD,CAAZ,EAAiB;;AAEjB,QAAI,CAACO,aAAa,CAACH,QAAd,CAAuBD,MAAvB,CAAL,EAAqC;AACnC;AACAS,MAAAA,QAAQ,CAACZ,CAAD,CAAR,GAAc,QAAd;AACA;AACD,KAP+B,CAShC;;;AACA,UAAMgB,kBAAkB,GAAGT,aAAa,CAACU,SAAd,CACzB,CAACC,CAAD,EAAIC,KAAJ,KAAcD,CAAC,KAAKf,MAAN,IAAgB,CAACM,kBAAkB,CAACU,KAAD,CADxB,CAA3B;;AAIA,QAAIH,kBAAkB,GAAG,CAAC,CAA1B,EAA6B;AAC3BJ,MAAAA,QAAQ,CAACZ,CAAD,CAAR,GAAc,SAAd;AACAS,MAAAA,kBAAkB,CAACO,kBAAD,CAAlB,GAAyC,IAAzC;AACA;AACD,KAJD,MAIO;AACLJ,MAAAA,QAAQ,CAACZ,CAAD,CAAR,GAAc,QAAd;AACA;AACD;AACF,GAtBD;AAwBA,SAAOY,QAAP;AACD,CA1CM","sourcesContent":["import { solution } from './words'\nimport { ORTHOGRAPHY } from '../constants/orthography'\nimport { ORTHOGRAPHY_PATTERN } from './tokenizer'\n\nexport type CharStatus = 'absent' | 'present' | 'correct'\n\nexport type CharValue = typeof ORTHOGRAPHY[number]\n\nexport const getStatuses = (\n  guesses: string[][]\n): { [key: string]: CharStatus } => {\n  const charObj: { [key: string]: CharStatus } = {}\n  const solutionChars = solution.split(ORTHOGRAPHY_PATTERN).filter((i) => i)\n  guesses.forEach((word) => {\n    word.forEach((letter, i) => {\n      if (!solutionChars.includes(letter)) {\n        // make status absent\n        return (charObj[letter] = 'absent')\n      }\n\n      if (letter === solutionChars[i]) {\n        //make status correct\n        return (charObj[letter] = 'correct')\n      }\n\n      if (charObj[letter] !== 'correct') {\n        //make status present\n        return (charObj[letter] = 'present')\n      }\n    })\n  })\n\n  return charObj\n}\n\nexport const getGuessStatuses = (guess: string[]): CharStatus[] => {\n  const splitSolution = solution.split(ORTHOGRAPHY_PATTERN).filter((i) => i)\n  const splitGuess = guess\n\n  const solutionCharsTaken = splitSolution.map((_) => false)\n\n  const statuses: CharStatus[] = Array.from(Array(guess.length))\n\n  // handle all correct cases first\n  splitGuess.forEach((letter, i) => {\n    if (letter === splitSolution[i]) {\n      statuses[i] = 'correct'\n      solutionCharsTaken[i] = true\n      return\n    }\n  })\n\n  splitGuess.forEach((letter, i) => {\n    if (statuses[i]) return\n\n    if (!splitSolution.includes(letter)) {\n      // handles the absent case\n      statuses[i] = 'absent'\n      return\n    }\n\n    // now we are left with \"present\"s\n    const indexOfPresentChar = splitSolution.findIndex(\n      (x, index) => x === letter && !solutionCharsTaken[index]\n    )\n\n    if (indexOfPresentChar > -1) {\n      statuses[i] = 'present'\n      solutionCharsTaken[indexOfPresentChar] = true\n      return\n    } else {\n      statuses[i] = 'absent'\n      return\n    }\n  })\n\n  return statuses\n}\n"]},"metadata":{},"sourceType":"module"}