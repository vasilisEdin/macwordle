{"ast":null,"code":"import { match } from './match.esm.js'; //  - https://stackoverflow.com/a/30753870\n\nvar focusableSelector = /*#__PURE__*/['[contentEditable=true]', '[tabindex]', 'a[href]', 'area[href]', 'button:not([disabled])', 'iframe', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])'].map(process.env.NODE_ENV === 'test' ? // TODO: Remove this once JSDOM fixes the issue where an element that is\n// \"hidden\" can be the document.activeElement, because this is not possible\n// in real browsers.\n// TODO: Remove this once JSDOM fixes the issue where an element that is\nfunction (selector) {\n  return selector + \":not([tabindex='-1']):not([style*='display: none'])\";\n} : function (selector) {\n  return selector + \":not([tabindex='-1'])\";\n}).join(',');\nvar Focus;\n\n(function (Focus) {\n  /** Focus the first non-disabled element */\n  Focus[Focus[\"First\"] = 1] = \"First\";\n  /** Focus the previous non-disabled element */\n\n  Focus[Focus[\"Previous\"] = 2] = \"Previous\";\n  /** Focus the next non-disabled element */\n\n  Focus[Focus[\"Next\"] = 4] = \"Next\";\n  /** Focus the last non-disabled element */\n\n  Focus[Focus[\"Last\"] = 8] = \"Last\";\n  /** Wrap tab around */\n\n  Focus[Focus[\"WrapAround\"] = 16] = \"WrapAround\";\n  /** Prevent scrolling the focusable elements into view */\n\n  Focus[Focus[\"NoScroll\"] = 32] = \"NoScroll\";\n})(Focus || (Focus = {}));\n\nvar FocusResult;\n\n(function (FocusResult) {\n  /** Something went wrong while trying to focus. */\n  FocusResult[FocusResult[\"Error\"] = 0] = \"Error\";\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N+1` where `N` is the last index in the array, then we overflow. */\n\n  FocusResult[FocusResult[\"Overflow\"] = 1] = \"Overflow\";\n  /** Focus was successful. */\n\n  FocusResult[FocusResult[\"Success\"] = 2] = \"Success\";\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N-1` where `N` is the first index in the array, then we underflow. */\n\n  FocusResult[FocusResult[\"Underflow\"] = 3] = \"Underflow\";\n})(FocusResult || (FocusResult = {}));\n\nvar Direction;\n\n(function (Direction) {\n  Direction[Direction[\"Previous\"] = -1] = \"Previous\";\n  Direction[Direction[\"Next\"] = 1] = \"Next\";\n})(Direction || (Direction = {}));\n\nfunction getFocusableElements(container) {\n  if (container === void 0) {\n    container = document.body;\n  }\n\n  if (container == null) return [];\n  return Array.from(container.querySelectorAll(focusableSelector));\n}\n\nvar FocusableMode;\n\n(function (FocusableMode) {\n  /** The element itself must be focusable. */\n  FocusableMode[FocusableMode[\"Strict\"] = 0] = \"Strict\";\n  /** The element should be inside of a focusable element. */\n\n  FocusableMode[FocusableMode[\"Loose\"] = 1] = \"Loose\";\n})(FocusableMode || (FocusableMode = {}));\n\nfunction isFocusableElement(element, mode) {\n  var _match;\n\n  if (mode === void 0) {\n    mode = FocusableMode.Strict;\n  }\n\n  if (element === document.body) return false;\n  return match(mode, (_match = {}, _match[FocusableMode.Strict] = function () {\n    return element.matches(focusableSelector);\n  }, _match[FocusableMode.Loose] = function () {\n    var next = element;\n\n    while (next !== null) {\n      if (next.matches(focusableSelector)) return true;\n      next = next.parentElement;\n    }\n\n    return false;\n  }, _match));\n}\n\nfunction focusElement(element) {\n  element == null ? void 0 : element.focus({\n    preventScroll: true\n  });\n}\n\nfunction focusIn(container, focus) {\n  var elements = Array.isArray(container) ? container : getFocusableElements(container);\n  var active = document.activeElement;\n\n  var direction = function () {\n    if (focus & (Focus.First | Focus.Next)) return Direction.Next;\n    if (focus & (Focus.Previous | Focus.Last)) return Direction.Previous;\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last');\n  }();\n\n  var startIndex = function () {\n    if (focus & Focus.First) return 0;\n    if (focus & Focus.Previous) return Math.max(0, elements.indexOf(active)) - 1;\n    if (focus & Focus.Next) return Math.max(0, elements.indexOf(active)) + 1;\n    if (focus & Focus.Last) return elements.length - 1;\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last');\n  }();\n\n  var focusOptions = focus & Focus.NoScroll ? {\n    preventScroll: true\n  } : {};\n  var offset = 0;\n  var total = elements.length;\n  var next = undefined;\n\n  do {\n    var _next; // Guard against infinite loops\n\n\n    if (offset >= total || offset + total <= 0) return FocusResult.Error;\n    var nextIdx = startIndex + offset;\n\n    if (focus & Focus.WrapAround) {\n      nextIdx = (nextIdx + total) % total;\n    } else {\n      if (nextIdx < 0) return FocusResult.Underflow;\n      if (nextIdx >= total) return FocusResult.Overflow;\n    }\n\n    next = elements[nextIdx]; // Try the focus the next element, might not work if it is \"hidden\" to the user.\n\n    (_next = next) == null ? void 0 : _next.focus(focusOptions); // Try the next one in line\n\n    offset += direction;\n  } while (next !== document.activeElement); // This is a little weird, but let me try and explain: There are a few scenario's\n  // in chrome for example where a focused `<a>` tag does not get the default focus\n  // styles and sometimes they do. This highly depends on whether you started by\n  // clicking or by using your keyboard. When you programmatically add focus `anchor.focus()`\n  // then the active element (document.activeElement) is this anchor, which is expected.\n  // However in that case the default focus styles are not applied *unless* you\n  // also add this tabindex.\n\n\n  if (!next.hasAttribute('tabindex')) next.setAttribute('tabindex', '0');\n  return FocusResult.Success;\n}\n\nexport { Focus, FocusResult, FocusableMode, focusElement, focusIn, getFocusableElements, isFocusableElement };","map":{"version":3,"mappings":"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","names":["focusableSelector","map","process","env","NODE_ENV","selector","join","Focus","FocusResult","Direction","getFocusableElements","container","document","body","Array","from","querySelectorAll","FocusableMode","isFocusableElement","element","mode","Strict","match","matches","Loose","next","parentElement","focusElement","focus","preventScroll","focusIn","elements","isArray","active","activeElement","direction","First","Next","Previous","Last","Error","startIndex","Math","max","indexOf","length","focusOptions","NoScroll","offset","total","undefined","nextIdx","WrapAround","Underflow","Overflow","hasAttribute","setAttribute","Success"],"sources":["C:\\Users\\Vasilis\\Documents\\GitHub\\macwordle\\node_modules\\@headlessui\\react\\src\\utils\\focus-management.ts"],"sourcesContent":["import { match } from './match'\n\n// Credit:\n//  - https://stackoverflow.com/a/30753870\nlet focusableSelector = [\n  '[contentEditable=true]',\n  '[tabindex]',\n  'a[href]',\n  'area[href]',\n  'button:not([disabled])',\n  'iframe',\n  'input:not([disabled])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n]\n  .map(\n    process.env.NODE_ENV === 'test'\n      ? // TODO: Remove this once JSDOM fixes the issue where an element that is\n        // \"hidden\" can be the document.activeElement, because this is not possible\n        // in real browsers.\n        selector => `${selector}:not([tabindex='-1']):not([style*='display: none'])`\n      : selector => `${selector}:not([tabindex='-1'])`\n  )\n  .join(',')\n\nexport enum Focus {\n  /** Focus the first non-disabled element */\n  First = 1 << 0,\n\n  /** Focus the previous non-disabled element */\n  Previous = 1 << 1,\n\n  /** Focus the next non-disabled element */\n  Next = 1 << 2,\n\n  /** Focus the last non-disabled element */\n  Last = 1 << 3,\n\n  /** Wrap tab around */\n  WrapAround = 1 << 4,\n\n  /** Prevent scrolling the focusable elements into view */\n  NoScroll = 1 << 5,\n}\n\nexport enum FocusResult {\n  /** Something went wrong while trying to focus. */\n  Error,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N+1` where `N` is the last index in the array, then we overflow. */\n  Overflow,\n\n  /** Focus was successful. */\n  Success,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N-1` where `N` is the first index in the array, then we underflow. */\n  Underflow,\n}\n\nenum Direction {\n  Previous = -1,\n  Next = 1,\n}\n\nexport function getFocusableElements(container: HTMLElement | null = document.body) {\n  if (container == null) return []\n  return Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n}\n\nexport enum FocusableMode {\n  /** The element itself must be focusable. */\n  Strict,\n\n  /** The element should be inside of a focusable element. */\n  Loose,\n}\n\nexport function isFocusableElement(\n  element: HTMLElement,\n  mode: FocusableMode = FocusableMode.Strict\n) {\n  if (element === document.body) return false\n\n  return match(mode, {\n    [FocusableMode.Strict]() {\n      return element.matches(focusableSelector)\n    },\n    [FocusableMode.Loose]() {\n      let next: HTMLElement | null = element\n\n      while (next !== null) {\n        if (next.matches(focusableSelector)) return true\n        next = next.parentElement\n      }\n\n      return false\n    },\n  })\n}\n\nexport function focusElement(element: HTMLElement | null) {\n  element?.focus({ preventScroll: true })\n}\n\nexport function focusIn(container: HTMLElement | HTMLElement[], focus: Focus) {\n  let elements = Array.isArray(container) ? container : getFocusableElements(container)\n  let active = document.activeElement as HTMLElement\n\n  let direction = (() => {\n    if (focus & (Focus.First | Focus.Next)) return Direction.Next\n    if (focus & (Focus.Previous | Focus.Last)) return Direction.Previous\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let startIndex = (() => {\n    if (focus & Focus.First) return 0\n    if (focus & Focus.Previous) return Math.max(0, elements.indexOf(active)) - 1\n    if (focus & Focus.Next) return Math.max(0, elements.indexOf(active)) + 1\n    if (focus & Focus.Last) return elements.length - 1\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let focusOptions = focus & Focus.NoScroll ? { preventScroll: true } : {}\n\n  let offset = 0\n  let total = elements.length\n  let next = undefined\n  do {\n    // Guard against infinite loops\n    if (offset >= total || offset + total <= 0) return FocusResult.Error\n\n    let nextIdx = startIndex + offset\n\n    if (focus & Focus.WrapAround) {\n      nextIdx = (nextIdx + total) % total\n    } else {\n      if (nextIdx < 0) return FocusResult.Underflow\n      if (nextIdx >= total) return FocusResult.Overflow\n    }\n\n    next = elements[nextIdx]\n\n    // Try the focus the next element, might not work if it is \"hidden\" to the user.\n    next?.focus(focusOptions)\n\n    // Try the next one in line\n    offset += direction\n  } while (next !== document.activeElement)\n\n  // This is a little weird, but let me try and explain: There are a few scenario's\n  // in chrome for example where a focused `<a>` tag does not get the default focus\n  // styles and sometimes they do. This highly depends on whether you started by\n  // clicking or by using your keyboard. When you programmatically add focus `anchor.focus()`\n  // then the active element (document.activeElement) is this anchor, which is expected.\n  // However in that case the default focus styles are not applied *unless* you\n  // also add this tabindex.\n  if (!next.hasAttribute('tabindex')) next.setAttribute('tabindex', '0')\n\n  return FocusResult.Success\n}\n"]},"metadata":{},"sourceType":"module"}