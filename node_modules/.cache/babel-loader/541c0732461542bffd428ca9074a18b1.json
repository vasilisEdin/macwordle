{"ast":null,"code":"import { disposables } from '../../../utils/disposables.esm.js';\nimport { once } from '../../../utils/once.esm.js';\n\nfunction addClasses(node) {\n  var _node$classList;\n\n  for (var _len = arguments.length, classes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    classes[_key - 1] = arguments[_key];\n  }\n\n  node && classes.length > 0 && (_node$classList = node.classList).add.apply(_node$classList, classes);\n}\n\nfunction removeClasses(node) {\n  var _node$classList2;\n\n  for (var _len2 = arguments.length, classes = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    classes[_key2 - 1] = arguments[_key2];\n  }\n\n  node && classes.length > 0 && (_node$classList2 = node.classList).remove.apply(_node$classList2, classes);\n}\n\nvar Reason;\n\n(function (Reason) {\n  Reason[\"Finished\"] = \"finished\";\n  Reason[\"Cancelled\"] = \"cancelled\";\n})(Reason || (Reason = {}));\n\nfunction waitForTransition(node, done) {\n  var d = disposables();\n  if (!node) return d.dispose; // Safari returns a comma separated list of values, so let's sort them and take the highest value.\n\n  var _getComputedStyle = getComputedStyle(node),\n      transitionDuration = _getComputedStyle.transitionDuration,\n      transitionDelay = _getComputedStyle.transitionDelay;\n\n  var _map = [transitionDuration, transitionDelay].map(function (value) {\n    var _value$split$filter$m = value.split(',') // Remove falsy we can't work with\n    .filter(Boolean) // Values are returned as `0.3s` or `75ms`\n    .map(function (v) {\n      return v.includes('ms') ? parseFloat(v) : parseFloat(v) * 1000;\n    }).sort(function (a, z) {\n      return z - a;\n    }),\n        _value$split$filter$m2 = _value$split$filter$m[0],\n        resolvedValue = _value$split$filter$m2 === void 0 ? 0 : _value$split$filter$m2;\n\n    return resolvedValue;\n  }),\n      durationMs = _map[0],\n      delaysMs = _map[1]; // Waiting for the transition to end. We could use the `transitionend` event, however when no\n  // actual transition/duration is defined then the `transitionend` event is not fired.\n  //\n  // TODO: Downside is, when you slow down transitions via devtools this timeout is still using the\n  // full 100% speed instead of the 25% or 10%.\n\n\n  if (durationMs !== 0) {\n    d.setTimeout(function () {\n      done(Reason.Finished);\n    }, durationMs + delaysMs);\n  } else {\n    // No transition is happening, so we should cleanup already. Otherwise we have to wait until we\n    // get disposed.\n    done(Reason.Finished);\n  } // If we get disposed before the timeout runs we should cleanup anyway\n\n\n  d.add(function () {\n    return done(Reason.Cancelled);\n  });\n  return d.dispose;\n}\n\nfunction transition(node, base, from, to, entered, done) {\n  var d = disposables();\n\n  var _done = done !== undefined ? once(done) : function () {};\n\n  removeClasses.apply(void 0, [node].concat(entered));\n  addClasses.apply(void 0, [node].concat(base, from));\n  d.nextFrame(function () {\n    removeClasses.apply(void 0, [node].concat(from));\n    addClasses.apply(void 0, [node].concat(to));\n    d.add(waitForTransition(node, function (reason) {\n      removeClasses.apply(void 0, [node].concat(to, base));\n      addClasses.apply(void 0, [node].concat(entered));\n      return _done(reason);\n    }));\n  }); // Once we get disposed, we should ensure that we cleanup after ourselves. In case of an unmount,\n  // the node itself will be nullified and will be a no-op. In case of a full transition the classes\n  // are already removed which is also a no-op. However if you go from enter -> leave mid-transition\n  // then we have some leftovers that should be cleaned.\n\n  d.add(function () {\n    return removeClasses.apply(void 0, [node].concat(base, from, to, entered));\n  }); // When we get disposed early, than we should also call the done method but switch the reason.\n\n  d.add(function () {\n    return _done(Reason.Cancelled);\n  });\n  return d.dispose;\n}\n\nexport { Reason, transition };","map":{"version":3,"mappings":"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","names":["addClasses","node","classes","length","classList","add","removeClasses","remove","Reason","waitForTransition","done","d","disposables","dispose","getComputedStyle","transitionDuration","transitionDelay","map","value","split","filter","Boolean","v","includes","parseFloat","sort","a","z","resolvedValue","_value$split$filter$m2","durationMs","delaysMs","setTimeout","Finished","Cancelled","transition","base","from","to","entered","_done","undefined","once","nextFrame","reason"],"sources":["C:\\Users\\Vasilis\\Documents\\GitHub\\macwordle\\node_modules\\@headlessui\\react\\src\\components\\transitions\\utils\\transition.ts"],"sourcesContent":["import { once } from '../../../utils/once'\nimport { disposables } from '../../../utils/disposables'\n\nfunction addClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.add(...classes)\n}\n\nfunction removeClasses(node: HTMLElement, ...classes: string[]) {\n  node && classes.length > 0 && node.classList.remove(...classes)\n}\n\nexport enum Reason {\n  Finished = 'finished',\n  Cancelled = 'cancelled',\n}\n\nfunction waitForTransition(node: HTMLElement, done: (reason: Reason) => void) {\n  let d = disposables()\n\n  if (!node) return d.dispose\n\n  // Safari returns a comma separated list of values, so let's sort them and take the highest value.\n  let { transitionDuration, transitionDelay } = getComputedStyle(node)\n\n  let [durationMs, delaysMs] = [transitionDuration, transitionDelay].map(value => {\n    let [resolvedValue = 0] = value\n      .split(',')\n      // Remove falsy we can't work with\n      .filter(Boolean)\n      // Values are returned as `0.3s` or `75ms`\n      .map(v => (v.includes('ms') ? parseFloat(v) : parseFloat(v) * 1000))\n      .sort((a, z) => z - a)\n\n    return resolvedValue\n  })\n\n  // Waiting for the transition to end. We could use the `transitionend` event, however when no\n  // actual transition/duration is defined then the `transitionend` event is not fired.\n  //\n  // TODO: Downside is, when you slow down transitions via devtools this timeout is still using the\n  // full 100% speed instead of the 25% or 10%.\n  if (durationMs !== 0) {\n    d.setTimeout(() => {\n      done(Reason.Finished)\n    }, durationMs + delaysMs)\n  } else {\n    // No transition is happening, so we should cleanup already. Otherwise we have to wait until we\n    // get disposed.\n    done(Reason.Finished)\n  }\n\n  // If we get disposed before the timeout runs we should cleanup anyway\n  d.add(() => done(Reason.Cancelled))\n\n  return d.dispose\n}\n\nexport function transition(\n  node: HTMLElement,\n  base: string[],\n  from: string[],\n  to: string[],\n  entered: string[],\n  done?: (reason: Reason) => void\n) {\n  let d = disposables()\n  let _done = done !== undefined ? once(done) : () => {}\n\n  removeClasses(node, ...entered)\n  addClasses(node, ...base, ...from)\n\n  d.nextFrame(() => {\n    removeClasses(node, ...from)\n    addClasses(node, ...to)\n\n    d.add(\n      waitForTransition(node, reason => {\n        removeClasses(node, ...to, ...base)\n        addClasses(node, ...entered)\n        return _done(reason)\n      })\n    )\n  })\n\n  // Once we get disposed, we should ensure that we cleanup after ourselves. In case of an unmount,\n  // the node itself will be nullified and will be a no-op. In case of a full transition the classes\n  // are already removed which is also a no-op. However if you go from enter -> leave mid-transition\n  // then we have some leftovers that should be cleaned.\n  d.add(() => removeClasses(node, ...base, ...from, ...to, ...entered))\n\n  // When we get disposed early, than we should also call the done method but switch the reason.\n  d.add(() => _done(Reason.Cancelled))\n\n  return d.dispose\n}\n"]},"metadata":{},"sourceType":"module"}