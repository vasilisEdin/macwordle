{"ast":null,"code":"import { createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { useRef, useEffect } from 'react';\nimport { Keys } from '../components/keyboard.esm.js';\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management.esm.js';\nimport { useWindowEvent } from './use-window-event.esm.js';\nimport { useIsMounted } from './use-is-mounted.esm.js';\nvar Features;\n\n(function (Features) {\n  /** No features enabled for the `useFocusTrap` hook. */\n  Features[Features[\"None\"] = 1] = \"None\";\n  /** Ensure that we move focus initially into the container. */\n\n  Features[Features[\"InitialFocus\"] = 2] = \"InitialFocus\";\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n\n  Features[Features[\"TabLock\"] = 4] = \"TabLock\";\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n\n  Features[Features[\"FocusLock\"] = 8] = \"FocusLock\";\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n\n  Features[Features[\"RestoreFocus\"] = 16] = \"RestoreFocus\";\n  /** Enable all features. */\n\n  Features[Features[\"All\"] = 30] = \"All\";\n})(Features || (Features = {}));\n\nfunction useFocusTrap(container, features, _temp) {\n  if (features === void 0) {\n    features = Features.All;\n  }\n\n  var _ref = _temp === void 0 ? {} : _temp,\n      initialFocus = _ref.initialFocus,\n      containers = _ref.containers;\n\n  var restoreElement = useRef(typeof window !== 'undefined' ? document.activeElement : null);\n  var previousActiveElement = useRef(null);\n  var mounted = useIsMounted();\n  var featuresRestoreFocus = Boolean(features & Features.RestoreFocus);\n  var featuresInitialFocus = Boolean(features & Features.InitialFocus); // Capture the currently focused element, before we enable the focus trap.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    restoreElement.current = document.activeElement;\n  }, [featuresRestoreFocus]); // Restore the focus when we unmount the component.\n\n  useEffect(function () {\n    if (!featuresRestoreFocus) return;\n    return function () {\n      focusElement(restoreElement.current);\n      restoreElement.current = null;\n    };\n  }, [featuresRestoreFocus]); // Handle initial focus\n\n  useEffect(function () {\n    if (!featuresInitialFocus) return;\n    if (!container.current) return;\n    var activeElement = document.activeElement;\n\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      if ((initialFocus == null ? void 0 : initialFocus.current) === activeElement) {\n        previousActiveElement.current = activeElement;\n        return; // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement;\n      return; // Already focused within Dialog\n    } // Try to focus the initialFocus ref\n\n\n    if (initialFocus == null ? void 0 : initialFocus.current) {\n      focusElement(initialFocus.current);\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />');\n      }\n    }\n\n    previousActiveElement.current = document.activeElement;\n  }, [container, initialFocus, featuresInitialFocus]); // Handle `Tab` & `Shift+Tab` keyboard events\n\n  useWindowEvent('keydown', function (event) {\n    if (!(features & Features.TabLock)) return;\n    if (!container.current) return;\n    if (event.key !== Keys.Tab) return;\n    event.preventDefault();\n\n    if (focusIn(container.current, (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround) === FocusResult.Success) {\n      previousActiveElement.current = document.activeElement;\n    }\n  }); // Prevent programmatically escaping the container\n\n  useWindowEvent('focus', function (event) {\n    if (!(features & Features.FocusLock)) return;\n    var allContainers = new Set(containers == null ? void 0 : containers.current);\n    allContainers.add(container);\n    if (!allContainers.size) return;\n    var previous = previousActiveElement.current;\n    if (!previous) return;\n    if (!mounted.current) return;\n    var toElement = event.target;\n\n    if (toElement && toElement instanceof HTMLElement) {\n      if (!contains(allContainers, toElement)) {\n        event.preventDefault();\n        event.stopPropagation();\n        focusElement(previous);\n      } else {\n        previousActiveElement.current = toElement;\n        focusElement(toElement);\n      }\n    } else {\n      focusElement(previousActiveElement.current);\n    }\n  }, true);\n}\n\nfunction contains(containers, element) {\n  for (var _iterator = _createForOfIteratorHelperLoose(containers), _step; !(_step = _iterator()).done;) {\n    var _container$current;\n\n    var container = _step.value;\n    if ((_container$current = container.current) == null ? void 0 : _container$current.contains(element)) return true;\n  }\n\n  return false;\n}\n\nexport { Features, useFocusTrap };","map":{"version":3,"mappings":"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","names":["Features","useFocusTrap","container","features","All","initialFocus","containers","restoreElement","useRef","window","document","activeElement","previousActiveElement","mounted","useIsMounted","featuresRestoreFocus","Boolean","RestoreFocus","featuresInitialFocus","InitialFocus","useEffect","current","focusElement","contains","focusIn","Focus","First","FocusResult","Error","console","warn","useWindowEvent","TabLock","event","key","Keys","Tab","preventDefault","shiftKey","Previous","Next","WrapAround","Success","FocusLock","allContainers","Set","add","size","previous","toElement","target","HTMLElement","stopPropagation","element","_container$current"],"sources":["C:\\Users\\Vasilis\\Documents\\GitHub\\vasilisEdin\\node_modules\\@headlessui\\react\\src\\hooks\\use-focus-trap.ts"],"sourcesContent":["import {\n  useRef,\n  // Types\n  MutableRefObject,\n  useEffect,\n} from 'react'\n\nimport { Keys } from '../components/keyboard'\nimport { focusElement, focusIn, Focus, FocusResult } from '../utils/focus-management'\nimport { useWindowEvent } from './use-window-event'\nimport { useIsMounted } from './use-is-mounted'\n\nexport enum Features {\n  /** No features enabled for the `useFocusTrap` hook. */\n  None = 1 << 0,\n\n  /** Ensure that we move focus initially into the container. */\n  InitialFocus = 1 << 1,\n\n  /** Ensure that pressing `Tab` and `Shift+Tab` is trapped within the container. */\n  TabLock = 1 << 2,\n\n  /** Ensure that programmatically moving focus outside of the container is disallowed. */\n  FocusLock = 1 << 3,\n\n  /** Ensure that we restore the focus when unmounting the component that uses this `useFocusTrap` hook. */\n  RestoreFocus = 1 << 4,\n\n  /** Enable all features. */\n  All = InitialFocus | TabLock | FocusLock | RestoreFocus,\n}\n\nexport function useFocusTrap(\n  container: MutableRefObject<HTMLElement | null>,\n  features: Features = Features.All,\n  {\n    initialFocus,\n    containers,\n  }: {\n    initialFocus?: MutableRefObject<HTMLElement | null>\n    containers?: MutableRefObject<Set<MutableRefObject<HTMLElement | null>>>\n  } = {}\n) {\n  let restoreElement = useRef<HTMLElement | null>(\n    typeof window !== 'undefined' ? (document.activeElement as HTMLElement) : null\n  )\n  let previousActiveElement = useRef<HTMLElement | null>(null)\n  let mounted = useIsMounted()\n\n  let featuresRestoreFocus = Boolean(features & Features.RestoreFocus)\n  let featuresInitialFocus = Boolean(features & Features.InitialFocus)\n\n  // Capture the currently focused element, before we enable the focus trap.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    restoreElement.current = document.activeElement as HTMLElement\n  }, [featuresRestoreFocus])\n\n  // Restore the focus when we unmount the component.\n  useEffect(() => {\n    if (!featuresRestoreFocus) return\n\n    return () => {\n      focusElement(restoreElement.current)\n      restoreElement.current = null\n    }\n  }, [featuresRestoreFocus])\n\n  // Handle initial focus\n  useEffect(() => {\n    if (!featuresInitialFocus) return\n    if (!container.current) return\n\n    let activeElement = document.activeElement as HTMLElement\n\n    if (initialFocus?.current) {\n      if (initialFocus?.current === activeElement) {\n        previousActiveElement.current = activeElement\n        return // Initial focus ref is already the active element\n      }\n    } else if (container.current.contains(activeElement)) {\n      previousActiveElement.current = activeElement\n      return // Already focused within Dialog\n    }\n\n    // Try to focus the initialFocus ref\n    if (initialFocus?.current) {\n      focusElement(initialFocus.current)\n    } else {\n      if (focusIn(container.current, Focus.First) === FocusResult.Error) {\n        console.warn('There are no focusable elements inside the <FocusTrap />')\n      }\n    }\n\n    previousActiveElement.current = document.activeElement as HTMLElement\n  }, [container, initialFocus, featuresInitialFocus])\n\n  // Handle `Tab` & `Shift+Tab` keyboard events\n  useWindowEvent('keydown', event => {\n    if (!(features & Features.TabLock)) return\n\n    if (!container.current) return\n    if (event.key !== Keys.Tab) return\n\n    event.preventDefault()\n\n    if (\n      focusIn(\n        container.current,\n        (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround\n      ) === FocusResult.Success\n    ) {\n      previousActiveElement.current = document.activeElement as HTMLElement\n    }\n  })\n\n  // Prevent programmatically escaping the container\n  useWindowEvent(\n    'focus',\n    event => {\n      if (!(features & Features.FocusLock)) return\n\n      let allContainers = new Set(containers?.current)\n      allContainers.add(container)\n\n      if (!allContainers.size) return\n\n      let previous = previousActiveElement.current\n      if (!previous) return\n      if (!mounted.current) return\n\n      let toElement = event.target as HTMLElement | null\n\n      if (toElement && toElement instanceof HTMLElement) {\n        if (!contains(allContainers, toElement)) {\n          event.preventDefault()\n          event.stopPropagation()\n          focusElement(previous)\n        } else {\n          previousActiveElement.current = toElement\n          focusElement(toElement)\n        }\n      } else {\n        focusElement(previousActiveElement.current)\n      }\n    },\n    true\n  )\n}\n\nfunction contains(containers: Set<MutableRefObject<HTMLElement | null>>, element: HTMLElement) {\n  for (let container of containers) {\n    if (container.current?.contains(element)) return true\n  }\n\n  return false\n}\n"]},"metadata":{},"sourceType":"module"}