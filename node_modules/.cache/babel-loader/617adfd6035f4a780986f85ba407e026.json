{"ast":null,"code":"import { objectWithoutPropertiesLoose as _objectWithoutPropertiesLoose, extends as _extends, createForOfIteratorHelperLoose as _createForOfIteratorHelperLoose } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { Fragment, isValidElement, cloneElement, createElement, forwardRef } from 'react';\nimport { match } from './match.esm.js';\nvar Features;\n\n(function (Features) {\n  /** No features at all */\n  Features[Features[\"None\"] = 0] = \"None\";\n  /**\r\n   * When used, this will allow us to use one of the render strategies.\r\n   *\r\n   * **The render strategies are:**\r\n   *    - **Unmount**   _(Will unmount the component.)_\r\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\r\n   */\n\n  Features[Features[\"RenderStrategy\"] = 1] = \"RenderStrategy\";\n  /**\r\n   * When used, this will allow the user of our component to be in control. This can be used when\r\n   * you want to transition based on some state.\r\n   */\n\n  Features[Features[\"Static\"] = 2] = \"Static\";\n})(Features || (Features = {}));\n\nvar RenderStrategy;\n\n(function (RenderStrategy) {\n  RenderStrategy[RenderStrategy[\"Unmount\"] = 0] = \"Unmount\";\n  RenderStrategy[RenderStrategy[\"Hidden\"] = 1] = \"Hidden\";\n})(RenderStrategy || (RenderStrategy = {}));\n\nfunction render(_ref) {\n  var props = _ref.props,\n      slot = _ref.slot,\n      defaultTag = _ref.defaultTag,\n      features = _ref.features,\n      _ref$visible = _ref.visible,\n      visible = _ref$visible === void 0 ? true : _ref$visible,\n      name = _ref.name; // Visible always render\n\n  if (visible) return _render(props, slot, defaultTag, name);\n  var featureFlags = features != null ? features : Features.None;\n\n  if (featureFlags & Features.Static) {\n    var _props$static = props[\"static\"],\n        isStatic = _props$static === void 0 ? false : _props$static,\n        rest = _objectWithoutPropertiesLoose(props, [\"static\"]); // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n\n\n    if (isStatic) return _render(rest, slot, defaultTag, name);\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    var _match;\n\n    var _props$unmount = props.unmount,\n        unmount = _props$unmount === void 0 ? true : _props$unmount,\n        _rest = _objectWithoutPropertiesLoose(props, [\"unmount\"]);\n\n    var strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden;\n    return match(strategy, (_match = {}, _match[RenderStrategy.Unmount] = function () {\n      return null;\n    }, _match[RenderStrategy.Hidden] = function () {\n      return _render(_extends({}, _rest, {\n        hidden: true,\n        style: {\n          display: 'none'\n        }\n      }), slot, defaultTag, name);\n    }, _match));\n  } // No features enabled, just render\n\n\n  return _render(props, slot, defaultTag, name);\n}\n\nfunction _render(props, slot, tag, name) {\n  var _ref2;\n\n  if (slot === void 0) {\n    slot = {};\n  }\n\n  var _omit = omit(props, ['unmount', 'static']),\n      _omit$as = _omit.as,\n      Component = _omit$as === void 0 ? tag : _omit$as,\n      children = _omit.children,\n      _omit$refName = _omit.refName,\n      refName = _omit$refName === void 0 ? 'ref' : _omit$refName,\n      passThroughProps = _objectWithoutPropertiesLoose(_omit, [\"as\", \"children\", \"refName\"]); // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n\n\n  var refRelatedProps = props.ref !== undefined ? (_ref2 = {}, _ref2[refName] = props.ref, _ref2) : {};\n  var resolvedChildren = typeof children === 'function' ? children(slot) : children; // Allow for className to be a function with the slot as the contents\n\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    passThroughProps.className = passThroughProps.className(slot);\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (!isValidElement(resolvedChildren) || Array.isArray(resolvedChildren) && resolvedChildren.length > 1) {\n        throw new Error(['Passing props on \"Fragment\"!', '', \"The current component <\" + name + \" /> is rendering a \\\"Fragment\\\".\", \"However we need to passthrough the following props:\", Object.keys(passThroughProps).map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n'), '', 'You can apply a few solutions:', ['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".', 'Render a single element as the child so that we can forward the props onto that element.'].map(function (line) {\n          return \"  - \" + line;\n        }).join('\\n')].join('\\n'));\n      }\n\n      return cloneElement(resolvedChildren, Object.assign({}, // Filter out undefined values so that they don't override the existing values\n      mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, ['onClick']), refRelatedProps));\n    }\n  }\n\n  return createElement(Component, Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps), resolvedChildren);\n}\n/**\r\n * We can use this function for the following useCase:\r\n *\r\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\r\n *\r\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\r\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\r\n * first child, that one should _also_ be called (but before this implementation, it was just\r\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\r\n * props of this component.\r\n *\r\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\r\n * so that we can refactor this later (if needed).\r\n */\n\n\nfunction mergeEventFunctions(passThroughProps, existingProps, functionsToMerge) {\n  var clone = Object.assign({}, passThroughProps);\n\n  var _loop = function _loop() {\n    var func = _step.value;\n\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      var _Object$assign;\n\n      Object.assign(clone, (_Object$assign = {}, _Object$assign[func] = function (event) {\n        // Props we control\n        if (!event.defaultPrevented) passThroughProps[func](event); // Existing props on the component\n\n        if (!event.defaultPrevented) existingProps[func](event);\n      }, _Object$assign));\n    }\n  };\n\n  for (var _iterator = _createForOfIteratorHelperLoose(functionsToMerge), _step; !(_step = _iterator()).done;) {\n    _loop();\n  }\n\n  return clone;\n}\n/**\r\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\r\n * wrap it in a forwardRef so that we _can_ passthrough the ref\r\n */\n\n\nfunction forwardRefWithAs(component) {\n  var _component$displayNam;\n\n  return Object.assign(forwardRef(component), {\n    displayName: (_component$displayNam = component.displayName) != null ? _component$displayNam : component.name\n  });\n}\n\nfunction compact(object) {\n  var clone = Object.assign({}, object);\n\n  for (var key in clone) {\n    if (clone[key] === undefined) delete clone[key];\n  }\n\n  return clone;\n}\n\nfunction omit(object, keysToOmit) {\n  if (keysToOmit === void 0) {\n    keysToOmit = [];\n  }\n\n  var clone = Object.assign({}, object);\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(keysToOmit), _step2; !(_step2 = _iterator2()).done;) {\n    var key = _step2.value;\n    if (key in clone) delete clone[key];\n  }\n\n  return clone;\n}\n\nexport { Features, RenderStrategy, forwardRefWithAs, render };","map":{"version":3,"mappings":"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","names":["Features","RenderStrategy","render","props","slot","defaultTag","features","visible","_ref$visible","name","_render","featureFlags","None","Static","isStatic","rest","unmount","strategy","Unmount","Hidden","match","hidden","style","display","tag","omit","as","Component","children","refName","_omit$refName","passThroughProps","refRelatedProps","ref","undefined","resolvedChildren","className","Fragment","Object","keys","length","isValidElement","Array","isArray","Error","map","line","join","cloneElement","assign","mergeEventFunctions","compact","createElement","existingProps","functionsToMerge","clone","func","event","defaultPrevented","_loop","forwardRefWithAs","component","forwardRef","displayName","object","key","keysToOmit"],"sources":["C:\\Users\\Vasilis\\Documents\\GitHub\\vasilisEdin\\node_modules\\@headlessui\\react\\src\\utils\\render.ts"],"sourcesContent":["import {\n  Fragment,\n  cloneElement,\n  createElement,\n  forwardRef,\n  isValidElement,\n\n  // Types\n  ElementType,\n  ReactElement,\n} from 'react'\nimport { Props, XOR, __, Expand } from '../types'\nimport { match } from './match'\n\nexport enum Features {\n  /** No features at all */\n  None = 0,\n\n  /**\n   * When used, this will allow us to use one of the render strategies.\n   *\n   * **The render strategies are:**\n   *    - **Unmount**   _(Will unmount the component.)_\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\n   */\n  RenderStrategy = 1,\n\n  /**\n   * When used, this will allow the user of our component to be in control. This can be used when\n   * you want to transition based on some state.\n   */\n  Static = 2,\n}\n\nexport enum RenderStrategy {\n  Unmount,\n  Hidden,\n}\n\ntype PropsForFeature<TPassedInFeatures extends Features, TForFeature extends Features, TProps> = {\n  [P in TPassedInFeatures]: P extends TForFeature ? TProps : __\n}[TPassedInFeatures]\n\nexport type PropsForFeatures<T extends Features> = XOR<\n  PropsForFeature<T, Features.Static, { static?: boolean }>,\n  PropsForFeature<T, Features.RenderStrategy, { unmount?: boolean }>\n>\n\nexport function render<TFeature extends Features, TTag extends ElementType, TSlot>({\n  props,\n  slot,\n  defaultTag,\n  features,\n  visible = true,\n  name,\n}: {\n  props: Expand<Props<TTag, TSlot, any> & PropsForFeatures<TFeature>>\n  slot?: TSlot\n  defaultTag: ElementType\n  features?: TFeature\n  visible?: boolean\n  name: string\n}) {\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name)\n\n  let featureFlags = features ?? Features.None\n\n  if (featureFlags & Features.Static) {\n    let { static: isStatic = false, ...rest } = props as PropsForFeatures<Features.Static>\n\n    // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n    if (isStatic) return _render(rest, slot, defaultTag, name)\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    let { unmount = true, ...rest } = props as PropsForFeatures<Features.RenderStrategy>\n    let strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n    return match(strategy, {\n      [RenderStrategy.Unmount]() {\n        return null\n      },\n      [RenderStrategy.Hidden]() {\n        return _render(\n          { ...rest, ...{ hidden: true, style: { display: 'none' } } },\n          slot,\n          defaultTag,\n          name\n        )\n      },\n    })\n  }\n\n  // No features enabled, just render\n  return _render(props, slot, defaultTag, name)\n}\n\nfunction _render<TTag extends ElementType, TSlot>(\n  props: Props<TTag, TSlot> & { ref?: unknown },\n  slot: TSlot = {} as TSlot,\n  tag: ElementType,\n  name: string\n) {\n  let { as: Component = tag, children, refName = 'ref', ...passThroughProps } = omit(props, [\n    'unmount',\n    'static',\n  ])\n\n  // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n  let refRelatedProps = props.ref !== undefined ? { [refName]: props.ref } : {}\n\n  let resolvedChildren = (typeof children === 'function' ? children(slot) : children) as\n    | ReactElement\n    | ReactElement[]\n\n  // Allow for className to be a function with the slot as the contents\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    ;(passThroughProps as any).className = passThroughProps.className(slot)\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (\n        !isValidElement(resolvedChildren) ||\n        (Array.isArray(resolvedChildren) && resolvedChildren.length > 1)\n      ) {\n        throw new Error(\n          [\n            'Passing props on \"Fragment\"!',\n            '',\n            `The current component <${name} /> is rendering a \"Fragment\".`,\n            `However we need to passthrough the following props:`,\n            Object.keys(passThroughProps)\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n            '',\n            'You can apply a few solutions:',\n            [\n              'Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\n              'Render a single element as the child so that we can forward the props onto that element.',\n            ]\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n          ].join('\\n')\n        )\n      }\n\n      return cloneElement(\n        resolvedChildren,\n        Object.assign(\n          {},\n          // Filter out undefined values so that they don't override the existing values\n          mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, [\n            'onClick',\n          ]),\n          refRelatedProps\n        )\n      )\n    }\n  }\n\n  return createElement(\n    Component,\n    Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps),\n    resolvedChildren\n  )\n}\n\n/**\n * We can use this function for the following useCase:\n *\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\n *\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\n * first child, that one should _also_ be called (but before this implementation, it was just\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\n * props of this component.\n *\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\n * so that we can refactor this later (if needed).\n */\nfunction mergeEventFunctions(\n  passThroughProps: Record<string, any>,\n  existingProps: Record<string, any>,\n  functionsToMerge: string[]\n) {\n  let clone = Object.assign({}, passThroughProps)\n  for (let func of functionsToMerge) {\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      Object.assign(clone, {\n        [func](event: { defaultPrevented: boolean }) {\n          // Props we control\n          if (!event.defaultPrevented) passThroughProps[func](event)\n\n          // Existing props on the component\n          if (!event.defaultPrevented) existingProps[func](event)\n        },\n      })\n    }\n  }\n\n  return clone\n}\n\n/**\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\n * wrap it in a forwardRef so that we _can_ passthrough the ref\n */\nexport function forwardRefWithAs<T extends { name: string; displayName?: string }>(\n  component: T\n): T & { displayName: string } {\n  return Object.assign(forwardRef((component as unknown) as any) as any, {\n    displayName: component.displayName ?? component.name,\n  })\n}\n\nfunction compact<T extends Record<any, any>>(object: T) {\n  let clone = Object.assign({}, object)\n  for (let key in clone) {\n    if (clone[key] === undefined) delete clone[key]\n  }\n  return clone\n}\n\nfunction omit<T extends Record<any, any>>(object: T, keysToOmit: string[] = []) {\n  let clone = Object.assign({}, object)\n  for (let key of keysToOmit) {\n    if (key in clone) delete clone[key]\n  }\n  return clone\n}\n"]},"metadata":{},"sourceType":"module"}