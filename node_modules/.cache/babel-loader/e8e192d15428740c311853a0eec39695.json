{"ast":null,"code":"import{solution}from'./words';import{ORTHOGRAPHY_PATTERN}from'./tokenizer';export var getStatuses=function getStatuses(guesses){var charObj={};var solutionChars=solution.split(ORTHOGRAPHY_PATTERN).filter(function(i){return i;});guesses.forEach(function(word){word.forEach(function(letter,i){if(!solutionChars.includes(letter)){// make status absent\nreturn charObj[letter]='absent';}if(letter===solutionChars[i]){//make status correct\nreturn charObj[letter]='correct';}if(charObj[letter]!=='correct'){//make status present\nreturn charObj[letter]='present';}});});return charObj;};export var getGuessStatuses=function getGuessStatuses(guess){var splitSolution=solution.split(ORTHOGRAPHY_PATTERN).filter(function(i){return i;});var splitGuess=guess;var solutionCharsTaken=splitSolution.map(function(_){return false;});var statuses=Array.from(Array(guess.length));// handle all correct cases first\nsplitGuess.forEach(function(letter,i){if(letter===splitSolution[i]){statuses[i]='correct';solutionCharsTaken[i]=true;return;}});splitGuess.forEach(function(letter,i){if(statuses[i])return;if(!splitSolution.includes(letter)){// handles the absent case\nstatuses[i]='absent';return;}// now we are left with \"present\"s\nvar indexOfPresentChar=splitSolution.findIndex(function(x,index){return x===letter&&!solutionCharsTaken[index];});if(indexOfPresentChar>-1){statuses[i]='present';solutionCharsTaken[indexOfPresentChar]=true;return;}else{statuses[i]='absent';return;}});return statuses;};","map":{"version":3,"sources":["C:/Users/Vasilis/Documents/GitHub/vasilisEdin/src/lib/statuses.ts"],"names":["solution","ORTHOGRAPHY_PATTERN","getStatuses","guesses","charObj","solutionChars","split","filter","i","forEach","word","letter","includes","getGuessStatuses","guess","splitSolution","splitGuess","solutionCharsTaken","map","_","statuses","Array","from","length","indexOfPresentChar","findIndex","x","index"],"mappings":"AAAA,OAASA,QAAT,KAAyB,SAAzB,CAEA,OAASC,mBAAT,KAAoC,aAApC,CAMA,MAAO,IAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CACzBC,OADyB,CAES,CAClC,GAAMC,CAAAA,OAAsC,CAAG,EAA/C,CACA,GAAMC,CAAAA,aAAa,CAAGL,QAAQ,CAACM,KAAT,CAAeL,mBAAf,EAAoCM,MAApC,CAA2C,SAACC,CAAD,QAAOA,CAAAA,CAAP,EAA3C,CAAtB,CACAL,OAAO,CAACM,OAAR,CAAgB,SAACC,IAAD,CAAU,CACxBA,IAAI,CAACD,OAAL,CAAa,SAACE,MAAD,CAASH,CAAT,CAAe,CAC1B,GAAI,CAACH,aAAa,CAACO,QAAd,CAAuBD,MAAvB,CAAL,CAAqC,CACnC;AACA,MAAQP,CAAAA,OAAO,CAACO,MAAD,CAAP,CAAkB,QAA1B,CACD,CAED,GAAIA,MAAM,GAAKN,aAAa,CAACG,CAAD,CAA5B,CAAiC,CAC/B;AACA,MAAQJ,CAAAA,OAAO,CAACO,MAAD,CAAP,CAAkB,SAA1B,CACD,CAED,GAAIP,OAAO,CAACO,MAAD,CAAP,GAAoB,SAAxB,CAAmC,CACjC;AACA,MAAQP,CAAAA,OAAO,CAACO,MAAD,CAAP,CAAkB,SAA1B,CACD,CACF,CAfD,EAgBD,CAjBD,EAmBA,MAAOP,CAAAA,OAAP,CACD,CAzBM,CA2BP,MAAO,IAAMS,CAAAA,gBAAgB,CAAG,QAAnBA,CAAAA,gBAAmB,CAACC,KAAD,CAAmC,CACjE,GAAMC,CAAAA,aAAa,CAAGf,QAAQ,CAACM,KAAT,CAAeL,mBAAf,EAAoCM,MAApC,CAA2C,SAACC,CAAD,QAAOA,CAAAA,CAAP,EAA3C,CAAtB,CACA,GAAMQ,CAAAA,UAAU,CAAGF,KAAnB,CAEA,GAAMG,CAAAA,kBAAkB,CAAGF,aAAa,CAACG,GAAd,CAAkB,SAACC,CAAD,QAAO,MAAP,EAAlB,CAA3B,CAEA,GAAMC,CAAAA,QAAsB,CAAGC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACP,KAAK,CAACS,MAAP,CAAhB,CAA/B,CAEA;AACAP,UAAU,CAACP,OAAX,CAAmB,SAACE,MAAD,CAASH,CAAT,CAAe,CAChC,GAAIG,MAAM,GAAKI,aAAa,CAACP,CAAD,CAA5B,CAAiC,CAC/BY,QAAQ,CAACZ,CAAD,CAAR,CAAc,SAAd,CACAS,kBAAkB,CAACT,CAAD,CAAlB,CAAwB,IAAxB,CACA,OACD,CACF,CAND,EAQAQ,UAAU,CAACP,OAAX,CAAmB,SAACE,MAAD,CAASH,CAAT,CAAe,CAChC,GAAIY,QAAQ,CAACZ,CAAD,CAAZ,CAAiB,OAEjB,GAAI,CAACO,aAAa,CAACH,QAAd,CAAuBD,MAAvB,CAAL,CAAqC,CACnC;AACAS,QAAQ,CAACZ,CAAD,CAAR,CAAc,QAAd,CACA,OACD,CAED;AACA,GAAMgB,CAAAA,kBAAkB,CAAGT,aAAa,CAACU,SAAd,CACzB,SAACC,CAAD,CAAIC,KAAJ,QAAcD,CAAAA,CAAC,GAAKf,MAAN,EAAgB,CAACM,kBAAkB,CAACU,KAAD,CAAjD,EADyB,CAA3B,CAIA,GAAIH,kBAAkB,CAAG,CAAC,CAA1B,CAA6B,CAC3BJ,QAAQ,CAACZ,CAAD,CAAR,CAAc,SAAd,CACAS,kBAAkB,CAACO,kBAAD,CAAlB,CAAyC,IAAzC,CACA,OACD,CAJD,IAIO,CACLJ,QAAQ,CAACZ,CAAD,CAAR,CAAc,QAAd,CACA,OACD,CACF,CAtBD,EAwBA,MAAOY,CAAAA,QAAP,CACD,CA1CM","sourcesContent":["import { solution } from './words'\nimport { ORTHOGRAPHY } from '../constants/orthography'\nimport { ORTHOGRAPHY_PATTERN } from './tokenizer'\n\nexport type CharStatus = 'absent' | 'present' | 'correct'\n\nexport type CharValue = typeof ORTHOGRAPHY[number]\n\nexport const getStatuses = (\n  guesses: string[][]\n): { [key: string]: CharStatus } => {\n  const charObj: { [key: string]: CharStatus } = {}\n  const solutionChars = solution.split(ORTHOGRAPHY_PATTERN).filter((i) => i)\n  guesses.forEach((word) => {\n    word.forEach((letter, i) => {\n      if (!solutionChars.includes(letter)) {\n        // make status absent\n        return (charObj[letter] = 'absent')\n      }\n\n      if (letter === solutionChars[i]) {\n        //make status correct\n        return (charObj[letter] = 'correct')\n      }\n\n      if (charObj[letter] !== 'correct') {\n        //make status present\n        return (charObj[letter] = 'present')\n      }\n    })\n  })\n\n  return charObj\n}\n\nexport const getGuessStatuses = (guess: string[]): CharStatus[] => {\n  const splitSolution = solution.split(ORTHOGRAPHY_PATTERN).filter((i) => i)\n  const splitGuess = guess\n\n  const solutionCharsTaken = splitSolution.map((_) => false)\n\n  const statuses: CharStatus[] = Array.from(Array(guess.length))\n\n  // handle all correct cases first\n  splitGuess.forEach((letter, i) => {\n    if (letter === splitSolution[i]) {\n      statuses[i] = 'correct'\n      solutionCharsTaken[i] = true\n      return\n    }\n  })\n\n  splitGuess.forEach((letter, i) => {\n    if (statuses[i]) return\n\n    if (!splitSolution.includes(letter)) {\n      // handles the absent case\n      statuses[i] = 'absent'\n      return\n    }\n\n    // now we are left with \"present\"s\n    const indexOfPresentChar = splitSolution.findIndex(\n      (x, index) => x === letter && !solutionCharsTaken[index]\n    )\n\n    if (indexOfPresentChar > -1) {\n      statuses[i] = 'present'\n      solutionCharsTaken[indexOfPresentChar] = true\n      return\n    } else {\n      statuses[i] = 'absent'\n      return\n    }\n  })\n\n  return statuses\n}\n"]},"metadata":{},"sourceType":"module"}